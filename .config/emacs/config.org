#+TITLE: Yonei's Emacs config
#+AUTHOR: Yonei <yonei@proton.me>
#+STARTUP: showeverything
#+OPTIONS: toc:2

* Table of contents :toc:
- [[#important-stuff-to-load-first][Important stuff to load first]]
  - [[#add-the-scripts-directory-to-path][Add the scripts directory to path]]
  - [[#source-the-scripts][Source the scripts]]
  - [[#evil-mode][Evil mode]]
  - [[#keybinds][Keybinds]]
- [[#visual-tweaks][Visual tweaks]]
  - [[#theme][Theme]]
  - [[#fonts][Fonts]]
  - [[#beacon][Beacon]]
  - [[#icons][Icons]]
  - [[#modeline][Modeline]]
- [[#sane-defaults][Sane defaults]]
- [[#improved-minibuffer-completion][Improved minibuffer completion]]
- [[#helpful][Helpful]]
- [[#dashboard][Dashboard]]
- [[#dired][Dired]]
  - [[#dired-collapse][Dired collapse]]
  - [[#sensible-directory-navigation][Sensible directory navigation]]
- [[#org-mode][Org mode]]
  - [[#fix-source-block-indentation][Fix source block indentation]]
  - [[#table-of-contents][Table of contents]]
  - [[#org-bullets][Org bullets]]
  - [[#org-tempo][Org tempo]]
  - [[#wysiwyg][WYSIWYG]]
  - [[#visual-tweaks-1][Visual tweaks]]
- [[#languages][Languages]]
  - [[#general-enhancments][General enhancments]]
  - [[#elisp][Elisp]]

* Important stuff to load first
** Add the scripts directory to path
#+begin_src elisp
(add-to-list 'load-path (expand-file-name "scripts" user-emacs-directory))
#+end_src

** Source the scripts
#+begin_src elisp
(require 'elpaca-bootstrap)  ;; Elpaca package manager setup
(require 'buffer-move)       ;; Move splits with ease
#+end_src

** Evil mode
#+begin_src elisp
;; Enable Evil
(use-package evil
  :elpaca t
  :init
  (setq evil-want-keybinding nil)
  (evil-mode))

;; Evil mode functionality for various other tools
(use-package evil-collection
  :elpaca t
  :after evil
  :config
  (setq evil-collection-mode-list '(dashboard dired help ibuffer))
  (evil-collection-init))
#+end_src

** Keybinds
#+begin_src elisp
(use-package general
  :elpaca t
  :demand t
  :config
  (general-evil-setup)

  ;; Set 'SPC' as global leader key
  (general-create-definer yonei/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; leader key
    :global-prefix "M-SPC") ;; leader key for insert mode

  (yonei/leader-keys
    "." '(find-file :wk "File search")
    "," '(switch-to-buffer :wk "Switch to buffer")

    "b" '(:ignore t :wk "buffer")
    "b i" '(ibuffer :wk "iBuffer")
    "b k" '(kill-this-buffer :wk "Kill current buffer")
    "b n" '(next-buffer :wk "Next buffer")
    "b p" '(previous-buffer :wk "Previous buffer")
    "b r" '(revert-buffer :wk "Reload buffer")

    "w" '(:ignore t :wk "window")
    "w c" '(delete-window :wk "Close current window")
    "w n" '(evil-window-vnew :wk "New window")
    "w s" '(evil-window-split :wk "Horizontal split")
    "w v" '(evil-window-vsplit :wk "Vertical split")
    ;; Window navigation
    "w h" '(evil-window-left :wk "Window left")
    "w j" '(evil-window-down :wk "Window down")
    "w k" '(evil-window-up :wk "Window up")
    "w l" '(evil-window-right :wk "Window right")
    "w w" '(evil-window-next :wk "Goto next window")
    ;; Window movement
    "w H" '(buf-move-left :wk "Buffer move left")
    "w J" '(buf-move-down :wk "Buffer move down")
    "w K" '(buf-move-up :wk "Buffer move up")
    "w L" '(buf-move-right :wk "Buffer move right")

    "e v" '(:ignore t :wk "evaluate")
    "e v b" '(eval-buffer :wk "Evaluate elisp in buffer")
    "e v d" '(eval-defun :wk "Evaluate defun containing or after point")
    "e v e" '(eval-expression :wk "Evaluate and elisp expression")
    "e v l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "e v r" '(eval-region :wk "Evaluate elisp in region")

    "f" '(:ignore t :wk "file")
    "f r" '(recentf :wk "Find recent files")
    "f c" '((lambda () (interactive)
              (find-file (expand-file-name "config.org" user-emacs-directory)))
            :wk "Open emacs config.org")

    "h" '(:ignore t :wk "help")
    "h f" '(describe-function :wk "Describe function")
    "h v" '(describe-variable :wk "Describe variable")
    "h r r" '((lambda () (interactive)
                (load-file user-init-file)
                (ignore (elpaca-process-queues)))
              :wk "Reload emacs config")))

;; IMPORTANT: Since `elpaca' installs and activates packages asynchronously, we need to load general early, otherwise the :general keyword in the use-package blocks won’t work. 
(elpaca-wait)

;; Exit the minibuffer by pressing 'ESC' 1 time instead of 3
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

*** Which-key
#+begin_src elisp
(use-package which-key
  :elpaca t
  :init
  (which-key-mode 1)
  :config
  (setq which-key-popup-type 'minibuffer
        which-key-sort-order #'which-key-key-order-alpha
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 6
        which-key-side-window-slot -10
        which-key-side-window-max-height 0.25
        which-key-idle-delay 0.8
        which-key-max-description-length 25
        which-key-allow-imprecise-window-fit t
        which-key-separator " → " ))
#+end_src


* Visual tweaks
** Theme
#+begin_src elisp
(use-package doom-themes
  :elpaca t
  :config
  ;; Global settings (defaults)
  ;; Set either to nil to universally disable
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (load-theme 'doom-one t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+end_src

** Fonts
TODO: Adjust this later
#+begin_src elisp
(set-face-attribute 'default nil
  :font "JetBrainsMono Nerd Font"
  :height 120
  :weight 'medium)
(set-face-attribute 'variable-pitch nil
  :font "Overpass"
  :height 140
  :weight 'medium)
(set-face-attribute 'fixed-pitch nil
  :font "JetBrainsMono Nerd Font"
  :height 120
  :weight 'medium)

;; Make commented text and keywords italics.
(set-face-attribute 'font-lock-comment-face nil :slant 'italic)
(set-face-attribute 'font-lock-keyword-face nil :slant 'italic)

;; This sets the default font on all graphical frames created after restarting Emacs.
;; Does the same thing as 'set-face-attribute default' above, but emacsclient fonts
;; are not right unless I also add this method of setting the default font.
(add-to-list 'default-frame-alist '(font . "JetBrains Mono-12"))
#+end_src

** Beacon
Silly, visually pleasing cursor effect that helps you locate the cursor.
#+begin_src elisp
(use-package beacon
  :elpaca t
  :init (beacon-mode 1)
  :config
  (setq beacon-blink-when-window-scrolls nil))
#+end_src

** Icons
#+begin_src elisp
(use-package all-the-icons
  :elpaca t
  :if (display-graphic-p))

(use-package nerd-icons
  :elpaca t)
#+end_src

** Modeline
#+begin_src elisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :config
  (setq doom-modeline-buffer-file-name-style 'truncate-nil
        doom-modeline-total-line-number t)
  (display-battery-mode 1)
  (column-number-mode 1))
#+end_src


* Sane defaults
#+begin_src elisp
(delete-selection-mode 1)             ;; Delete selected text by typing
(menu-bar-mode -1)                    ;; Disable menu bar
(global-display-line-numbers-mode 1)  ;; Display line numbers
(global-visual-line-mode t)           ;; Wrap lines by default
(global-auto-revert-mode t)           ;; Automatically show changes if the file has changed

(if (display-graphic-p)
    (progn (tool-bar-mode -1)
           (scroll-bar-mode -1)))

(setq delete-by-moving-to-trash t)    ;; Move files to trash when deleting
(defalias 'yes-or-no-p 'y-or-n-p)     ;; Answer just 'y' or 'n' instead of full words

;; Fix tabs
(setq-default indent-tabs-mode nil  ;; Tabs to spaces
              tab-width 4)
;; Only indent the line if at BOL or in a line's indentation. Otherwise insert a "real" TAB.
(setq-default tab-always-indent nil)
#+end_src

* Improved minibuffer completion
There are many choices, we go with vertico & marginalia instead of counsel, ivy & ivy rich.
#+begin_src elisp
(use-package vertico
  :elpaca t
  :init (vertico-mode)
  :general
  (:keymaps 'vertico-map
   "C-j" 'vertico-next
   "C-k" 'vertico-previous)
  :custom
  (vertico-cycle t))  ;; Wrap around when reaching end of list

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :elpaca nil
  :init
  (savehist-mode))

(use-package marginalia
  :elpaca t
  :after vertico
  :init (marginalia-mode))

(use-package vertico-prescient
  :elpaca t
  :after vertico
  :init (vertico-prescient-mode))
#+end_src

* Helpful
An alternative to the built-in Emacs help that provides much more contextual information.
#+begin_src elisp
(use-package helpful
  :elpaca t
  :after evil
  :general
  ([remap describe-function] 'helpful-callable
   [remap describe-command] 'helpful-command
   [remap describe-variable] 'helpful-variable
   [remap describe-symbol] 'helpful-symbol
   [remap describe-key] 'helpful-key))
#+end_src

* Dashboard
#+begin_src elisp
(use-package dashboard
  :elpaca t
  :config
  (add-hook 'elpaca-after-init-hook #'dashboard-insert-startupify-lists)
  (add-hook 'elpaca-after-init-hook #'dashboard-initialize)
  (dashboard-setup-startup-hook)

  ;; Show dashboard in frames created by 'emacsclient -c'.
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  (setq dashboard-startup-banner 'logo
        dashboard-center-content t
        dashboard-icon-type 'all-the-icons
        dashboard-set-file-icons t))
#+end_src

* Dired
#+begin_src elisp
(use-package dired
  :elpaca nil
  :custom
  (dired-listing-switches "-alh --group-directories-first"))
#+end_src

** Dired collapse
Mimic how GitHub renders file paths: if there is a chain of directories where each one only has one child, they are concatenated together and shown on the first level in this collapsed form.
#+begin_src elisp
(use-package dired-collapse
  :elpaca t
  :hook (dired-mode . dired-collapse-mode))
#+end_src

** Sensible directory navigation
This package provides a way to reuse the current dired buffer to visit another directory (rather than creating a new buffer for the new directory).
#+begin_src elisp
(use-package dired-single
  :elpaca t
  :general
  (:keymaps 'dired-mode-map
   [remap dired-find-file] #'dired-single-buffer
   [remap dired-mouse-find-file-other-window] #'dired-single-buffer-mouse
   [remap dired-up-directory] #'dired-single-up-directory))
#+end_src

* Org mode
#+begin_src elisp
(use-package org
  :elpaca nil
  :defer t
  :hook (org-mode . org-indent-mode)
  :general
  (:keymaps 'org-mode-map
   :states '(insert emacs)
   "RET" '+org/return)
  (:keymaps 'org-mode-map
   :states 'normal 
   "RET" 'org-return
   (kbd "<tab>") 'org-cycle)
  :custom
  (org-ellipsis " ▼ ")
  (org-edit-src-content-indentation 0)  ;; Org src block automatic indent from 2 to 0
  (org-src-tab-acts-natively t)
  (org-return-follows-link t))
#+end_src

** Fix source block indentation
Taken from Doom Emacs.
#+begin_src elisp
;;;###autoload
(defun +org/return ()
  "Call `org-return' then indent (if `electric-indent-mode' is on)."
  (interactive)
  (org-return electric-indent-mode))

(defun yn/org-src-fix-newline-and-indent-a (&optional indent _arg _interactive)
  "Mimic `newline-and-indent' in src blocks w/ lang-appropriate indentation."
  (when (and indent
             org-src-tab-acts-natively
             (org-in-src-block-p t))
    (save-window-excursion
      (org-babel-do-in-edit-buffer
       (call-interactively #'indent-for-tab-command)))))

(advice-add 'org-return :after #'yn/org-src-fix-newline-and-indent-a)
#+end_src

** Table of contents
#+begin_src elisp
(use-package toc-org
  :elpaca t
  :commands toc-org-enable
  :hook (org-mode . toc-org-enable))
#+end_src

** Org bullets
#+begin_src elisp
(use-package org-bullets
  :elpaca t
  :hook (org-mode . org-bullets-mode))
#+end_src

** Org tempo
The =org-tempo= module allows inserting structural blocks with a few keystrokes.
Org Tempo expands snippets to structures defined in =org-structure-template-alist= and =org-tempo-keywords-alist=.

| Typing the below + TAB | Expands to ...                          |
|------------------------+-----------------------------------------|
| <a                     | '#+BEGIN_EXPORT ascii' … '#+END_EXPORT  |
| <c                     | '#+BEGIN_CENTER' … '#+END_CENTER'       |
| <C                     | '#+BEGIN_COMMENT' … '#+END_COMMENT'     |
| <e                     | '#+BEGIN_EXAMPLE' … '#+END_EXAMPLE'     |
| <E                     | '#+BEGIN_EXPORT' … '#+END_EXPORT'       |
| <h                     | '#+BEGIN_EXPORT html' … '#+END_EXPORT'  |
| <l                     | '#+BEGIN_EXPORT latex' … '#+END_EXPORT' |
| <q                     | '#+BEGIN_QUOTE' … '#+END_QUOTE'         |
| <s                     | '#+BEGIN_SRC' … '#+END_SRC'             |
| <v                     | '#+BEGIN_VERSE' … '#+END_VERSE'         |

#+begin_src elisp
(require 'org-tempo)
#+end_src

** WYSIWYG
Disable WYSIWYG while mousing over in insert mode for easier editing.
#+begin_src elisp
(use-package org-appear
  :elpaca t
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-hide-emphasis-markers t
        org-appear-autolinks t
        org-appear-trigger 'manual)

  ;; Additional hook for Evil mode integration
  :hook (org-mode . (lambda ()
                      (add-hook 'evil-insert-state-entry-hook
                                #'org-appear-manual-start
                                nil
                                t)
                      (add-hook 'evil-insert-state-exit-hook
                                #'org-appear-manual-stop
                                nil
                                t))))
#+end_src

** Visual tweaks
*** Different list characters per embedding level
[[https://emacs.stackexchange.com/a/45727]]

#+begin_src elisp
;; First
(font-lock-add-keywords 'org-mode
  '(("^\\(-\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
;; Second embedding
(font-lock-add-keywords 'org-mode
  `((,(concat "^[[:space:]]\\{" (number-to-string
                                (+ 2 org-list-indent-offset)) "\\}\\(-\\) ")
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦"))))))
;; Third embedding
(font-lock-add-keywords 'org-mode
  `((,(concat "^[[:space:]]\\{" (number-to-string
                                (* 2 (+ 2 org-list-indent-offset))) "\\}\\(-\\) ")
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "▸"))))))
;; Forth embedding
(font-lock-add-keywords 'org-mode
  `((,(concat "^[[:space:]]\\{" (number-to-string
                                (* 3 (+ 2 org-list-indent-offset))) "\\}\\(-\\) ")
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "▹"))))))
#+end_src

*** Center Org buffers for readability
#+begin_src elisp
(use-package visual-fill-column
  :elpaca t
  :hook (org-mode . visual-fill-column-mode)
  :config
  (setq-default visual-fill-column-width 100
                visual-fill-column-center-text t))
#+end_src

*** Heading sizes
#+begin_src elisp
(custom-set-faces
  '(org-level-1 ((t (:inherit outline-1 :height 1.5))))
  '(org-level-2 ((t (:inherit outline-2 :height 1.3))))
  '(org-level-3 ((t (:inherit outline-3 :height 1.15))))
  '(org-level-4 ((t (:inherit outline-4 :height 1.05))))
  '(org-document-title ((t (:height 1.75 :underline nil)))))
#+end_src

* Languages
** General enhancments
#+begin_src elisp
(use-package highlight-escape-sequences
  :elpaca
  (:host github
   :repo "hlissner/highlight-escape-sequences")
  :hook ((prog-mode conf-mode) . highlight-escape-sequences-mode))

;; Many major modes do no highlighting of number literals, so we do it for them
(use-package highlight-numbers
  :elpaca t
  :hook ((prog-mode conf-mode) . highlight-numbers-mode)
  :config
  (setq highlight-numbers-generic-regexp "\\_<[[:digit:]]+\\(?:\\.[0-9]*\\)?\\_>"))
#+end_src

** Elisp
#+begin_src elisp
;; NOTE: Can be also used for: clojure-mode, racket-mode, lisp-mode
(use-package highlight-quoted
  :elpaca t
  :hook (emacs-lisp-mode . highlight-quoted-mode))

(use-package rainbow-delimiters
  :elpaca t
  :hook (emacs-lisp-mode . rainbow-delimiters-mode)
  :config
  ;; Helps us distinguish stacked delimiter pairs, especially in parentheses-drunk
  ;; languages like Lisp. I reduce it from it's default of 9 to reduce the
  ;; complexity of the font-lock keyword and hopefully buy us a few ms of
  ;; performance.
  (setq rainbow-delimiters-max-face-count 4))
#+end_src

*** Enhance syntax highlighting
Code taken from Doom Emacs ([[https://github.com/doomemacs/doomemacs/blob/03d692f129633e3bf0bd100d91b3ebf3f77db6d1/modules/lang/emacs-lisp/autoload.el#L346-L381][Source]]).

#+begin_src elisp
(defvar +emacs-lisp--face nil)
(defvar +emacs-lisp-enable-extra-fontification t
  "If non-nil, highlight special forms, defined functions, and variables.")

;;;###autoload
(defun +emacs-lisp-highlight-vars-and-faces (end)
  "Match defined variables and functions.

Functions are differentiated into special forms, built-in functions and
library/userland functions"
  (catch 'matcher
    (while (re-search-forward "\\(?:\\sw\\|\\s_\\)+" end t)
      (let ((ppss (save-excursion (syntax-ppss))))
        (cond ((nth 3 ppss)  ; strings
               (search-forward "\"" end t))
              ((nth 4 ppss)  ; comments
               (forward-line +1))
              ((let ((symbol (intern-soft (match-string-no-properties 0))))
                 (and (cond ((null symbol) nil)
                            ((eq symbol t) nil)
                            ((keywordp symbol) nil)
                            ((special-variable-p symbol)
                             (setq +emacs-lisp--face 'font-lock-variable-name-face))
                            ((and (fboundp symbol)
                                  (eq (char-before (match-beginning 0)) ?\()
                                  (not (memq (char-before (1- (match-beginning 0)))
                                             (list ?\' ?\`))))
                             (let ((unaliased (indirect-function symbol)))
                               (unless (or (macrop unaliased)
                                           (special-form-p unaliased))
                                 (let (unadvised)
                                   (while (not (eq (setq unadvised (ad-get-orig-definition unaliased))
                                                   (setq unaliased (indirect-function unadvised)))))
                                   unaliased)
                                 (setq +emacs-lisp--face
                                       (if (subrp unaliased)
                                           'font-lock-constant-face
                                         'font-lock-function-name-face))))))
                      (throw 'matcher t)))))))
    nil))

(font-lock-add-keywords 'emacs-lisp-mode
   (append (when +emacs-lisp-enable-extra-fontification
              `((+emacs-lisp-highlight-vars-and-faces . +emacs-lisp--face)))))
#+end_src

*** Enhance default function indentation
Code taken from Doom Emacs ([[https://github.com/doomemacs/doomemacs/blob/03d692f129633e3bf0bd100d91b3ebf3f77db6d1/modules/lang/emacs-lisp/autoload.el#L127-L173][Source]]).

#+begin_src elisp
;;;###autoload
(defun +emacs-lisp-indent-function (indent-point state)
  "A replacement for `lisp-indent-function'.

Indents plists more sensibly. Adapted from
https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned"
  (let ((normal-indent (current-column))
        (orig-point (point))
        ;; TODO Refactor `target' usage (ew!)
        target)
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond ((and (elt state 2)
                (or (eq (char-after) ?:)
                    (not (looking-at-p "\\sw\\|\\s_"))))
           (if (lisp--local-defform-body-p state)
               (lisp-indent-defform state indent-point)
             (unless (> (save-excursion (forward-line 1) (point))
                        calculate-lisp-indent-last-sexp)
               (goto-char calculate-lisp-indent-last-sexp)
               (beginning-of-line)
               (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
             (backward-prefix-chars)
             (current-column)))
          ((and (save-excursion
                  (goto-char indent-point)
                  (skip-syntax-forward " ")
                  (not (eq (char-after) ?:)))
                (save-excursion
                  (goto-char orig-point)
                  (and (eq (char-after) ?:)
                       (eq (char-before) ?\()
                       (setq target (current-column)))))
           (save-excursion
             (move-to-column target t)
             target))
          ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                  (method (or (function-get (intern-soft function) 'lisp-indent-function)
                              (get (intern-soft function) 'lisp-indent-hook))))
             (cond ((or (eq method 'defun)
                        (and (null method)
                             (> (length function) 3)
                             (string-match-p "\\`def" function)))
                    (lisp-indent-defform state indent-point))
                   ((integerp method)
                    (lisp-indent-specform method state indent-point normal-indent))
                   (method
                    (funcall method indent-point state))))))))
#+end_src
*** Enhance default list indentation
Code taken from Doom Emacs ([[https://github.com/doomemacs/doomemacs/blob/03d692f129633e3bf0bd100d91b3ebf3f77db6d1/modules/lang/emacs-lisp/autoload.el#L412-L614][Source]]).

#+begin_src elisp
;;;###autoload
(defun yn/elisp--calculate-lisp-indent-a (&optional parse-start)
  "Add better indentation for quoted and backquoted lists.

Intended as :override advice for `calculate-lisp-indent'.

Adapted from URL `https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/'."
  ;; This line because `calculate-lisp-indent-last-sexp` was defined with
  ;; `defvar` with it's value ommited, marking it special and only defining it
  ;; locally. So if you don't have this, you'll get a void variable error.
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start)
             (beginning-of-defun))
            ((setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren. Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.  Indent under
                 ;; that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      ;; Containing sexp has nothing before this line except the
                      ;; first element. Indent under that element.
                      (= (point) calculate-lisp-indent-last-sexp)

                      (or
                       ;; Align keywords in plists if each newline begins with
                       ;; a keyword. This is useful for "unquoted plist
                       ;; function" macros, like `map!' and `defhydra'.
                       (when-let ((first (elt state 1))
                                  (char (char-after (1+ first))))
                         (and (eq char ?:)
                              (ignore-errors
                                (or (save-excursion
                                      (goto-char first)
                                      ;; FIXME Can we avoid `syntax-ppss'?
                                      (when-let* ((parse-sexp-ignore-comments t)
                                                  (end (scan-lists (point) 1 0))
                                                  (depth (ppss-depth (syntax-ppss))))
                                        (and (re-search-forward "^\\s-*:" end t)
                                             (= (ppss-depth (syntax-ppss))
                                                (1+ depth)))))
                                    (save-excursion
                                      (cl-loop for pos in (reverse (elt state 9))
                                               unless (memq (char-after (1+ pos)) '(?: ?\())
                                               do (goto-char (1+ pos))
                                               for fn = (read (current-buffer))
                                               if (symbolp fn)
                                               return (function-get fn 'indent-plists-as-data)))))))

                       ;; Check for quotes or backquotes around.
                       (let ((positions (elt state 9))
                             (quotep 0))
                         (while positions
                           (let ((point (pop positions)))
                             (or (when-let (char (char-before point))
                                   (cond
                                    ((eq char ?\())
                                    ((memq char '(?\' ?\`))
                                     (or (save-excursion
                                           (goto-char (1+ point))
                                           (skip-chars-forward "( ")
                                           (when-let (fn (ignore-errors (read (current-buffer))))
                                             (if (and (symbolp fn)
                                                      (fboundp fn)
                                                      ;; Only special forms and
                                                      ;; macros have special
                                                      ;; indent needs.
                                                      (not (functionp fn)))
                                                 (setq quotep 0))))
                                         (cl-incf quotep)))
                                    ((memq char '(?, ?@))
                                     (setq quotep 0))))
                                 ;; If the spelled out `quote' or `backquote'
                                 ;; are used, let's assume
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (and (looking-at-p "\\(\\(?:back\\)?quote\\)[\t\n\f\s]+(")
                                        (cl-incf quotep 2)))
                                 (setq quotep (max 0 (1- quotep))))))
                         (> quotep 0))))
                     ;; Containing sexp has nothing before this line except the
                     ;; first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's almost
                 ;; certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset or
      ;; if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment or it does not apply
                ;; to this argument, try to align a constant-symbol under the
                ;; last preceding constant symbol, if there is such one of the
                ;; last 2 preceding symbols, in the previous uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation where it
                     ;; begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace following an
                       ;; open paren. (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant as
                ;; defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (normal-indent))))))

(advice-add #'calculate-lisp-indent :override #'yn/elisp--calculate-lisp-indent-a)
#+end_src

